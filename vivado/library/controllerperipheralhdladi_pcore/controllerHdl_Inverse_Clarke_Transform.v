// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\controllerPeripheralHdlAdi\controllerHdl\controllerHdl_Inverse_Clarke_Transform.v
// Created: 2014-09-08 14:12:04
// 
// Generated by MATLAB 8.2 and HDL Coder 3.3
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: controllerHdl_Inverse_Clarke_Transform
// Source Path: controllerHdl/Field_Oriented_Control/Open_Loop_Control/Transform_dq_to_ABC/Inverse_Clarke_Transform
// Hierarchy Level: 5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module controllerHdl_Inverse_Clarke_Transform
          (
           alpha_voltage,
           beta_voltage,
           phase_voltages_0,
           phase_voltages_1,
           phase_voltages_2
          );


  input   signed [17:0] alpha_voltage;  // sfix18_En10
  input   signed [17:0] beta_voltage;  // sfix18_En10
  output  signed [17:0] phase_voltages_0;  // sfix18_En13
  output  signed [17:0] phase_voltages_1;  // sfix18_En13
  output  signed [17:0] phase_voltages_2;  // sfix18_En13


  wire signed [35:0] voltage_phase_a;  // sfix36_En26
  wire signed [35:0] Gain1_out1;  // sfix36_En26
  wire signed [35:0] Gain_out1;  // sfix36_En26
  wire signed [35:0] voltage_phase_b;  // sfix36_En26
  wire signed [37:0] Add1_cast;  // sfix38_En26
  wire signed [37:0] Add1_cast_1;  // sfix38_En26
  wire signed [37:0] Add1_sub_cast;  // sfix38_En26
  wire signed [37:0] Add1_sub_temp;  // sfix38_En26
  wire signed [35:0] voltage_phase_c;  // sfix36_En26
  wire signed [35:0] Mux_out1 [0:2];  // sfix36_En26 [3]
  wire signed [17:0] Current_Data_Type_out1 [0:2];  // sfix18_En13 [3]

  // Inverse Clarke Transform
  // 
  // Converts direct axis (alpha) component and the quadrature axis (beta) component to balanced three-phase quantities
  // The alpha and beta components are dependent on time and speed.


  // <S39>/Data Type Conversion
  assign voltage_phase_a = {{2{alpha_voltage[17]}}, {alpha_voltage, 16'b0000000000000000}};



  // <S39>/Gain1
  assign Gain1_out1 = 56756 * beta_voltage;



  // <S39>/Gain
  assign Gain_out1 = {{3{alpha_voltage[17]}}, {alpha_voltage, 15'b000000000000000}};



  // <S39>/Add
  assign voltage_phase_b = Gain1_out1 - Gain_out1;



  // <S39>/Add1
  assign Add1_cast = Gain_out1;
  assign Add1_cast_1 =  - (Add1_cast);
  assign Add1_sub_cast = Gain1_out1;
  assign Add1_sub_temp = Add1_cast_1 - Add1_sub_cast;
  assign voltage_phase_c = Add1_sub_temp[35:0];



  // <S39>/Mux
  assign Mux_out1[0] = voltage_phase_a;
  assign Mux_out1[1] = voltage_phase_b;
  assign Mux_out1[2] = voltage_phase_c;

  // <S39>/Current_Data_Type
  assign Current_Data_Type_out1[0] = ((Mux_out1[0][35] == 1'b0) && (Mux_out1[0][34:30] != 5'b00000) ? 18'sb011111111111111111 :
              ((Mux_out1[0][35] == 1'b1) && (Mux_out1[0][34:30] != 5'b11111) ? 18'sb100000000000000000 :
              $signed(Mux_out1[0][30:13])));
  assign Current_Data_Type_out1[1] = ((Mux_out1[1][35] == 1'b0) && (Mux_out1[1][34:30] != 5'b00000) ? 18'sb011111111111111111 :
              ((Mux_out1[1][35] == 1'b1) && (Mux_out1[1][34:30] != 5'b11111) ? 18'sb100000000000000000 :
              $signed(Mux_out1[1][30:13])));
  assign Current_Data_Type_out1[2] = ((Mux_out1[2][35] == 1'b0) && (Mux_out1[2][34:30] != 5'b00000) ? 18'sb011111111111111111 :
              ((Mux_out1[2][35] == 1'b1) && (Mux_out1[2][34:30] != 5'b11111) ? 18'sb100000000000000000 :
              $signed(Mux_out1[2][30:13])));



  assign phase_voltages_0 = Current_Data_Type_out1[0];

  assign phase_voltages_1 = Current_Data_Type_out1[1];

  assign phase_voltages_2 = Current_Data_Type_out1[2];

endmodule  // controllerHdl_Inverse_Clarke_Transform

