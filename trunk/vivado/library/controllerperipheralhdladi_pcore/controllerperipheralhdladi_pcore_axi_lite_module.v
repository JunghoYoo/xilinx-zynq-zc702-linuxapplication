// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\controllerPeripheralHdlAdi\controllerperipheralhdladi_pcore_axi_lite_module.v
// Created: 2014-09-08 14:12:15
// 
// Generated by MATLAB 8.2 and HDL Coder 3.3
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: controllerperipheralhdladi_pcore_axi_lite_module
// Source Path: controllerperipheralhdladi_pcore/controllerperipheralhdladi_pcore_axi_lite/controllerperipheralhdladi_pcore_axi_lite_module
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module controllerperipheralhdladi_pcore_axi_lite_module
          (
           CLK_IN,
           AXI_Lite_ARESETN,
           AXI_Lite_AWADDR,
           AXI_Lite_AWVALID,
           AXI_Lite_WDATA,
           AXI_Lite_WSTRB,
           AXI_Lite_WVALID,
           AXI_Lite_BREADY,
           AXI_Lite_ARADDR,
           AXI_Lite_ARVALID,
           AXI_Lite_RREADY,
           data_read,
           AXI_Lite_AWREADY,
           AXI_Lite_WREADY,
           AXI_Lite_BRESP,
           AXI_Lite_BVALID,
           AXI_Lite_ARREADY,
           AXI_Lite_RDATA,
           AXI_Lite_RRESP,
           AXI_Lite_RVALID,
           data_write,
           addr_sel,
           wr_enb,
           rd_enb,
           reset_internal
          );


  input   CLK_IN;
  input   AXI_Lite_ARESETN;  // ufix1
  input   [31:0] AXI_Lite_AWADDR;  // ufix32
  input   AXI_Lite_AWVALID;  // ufix1
  input   [31:0] AXI_Lite_WDATA;  // ufix32
  input   [3:0] AXI_Lite_WSTRB;  // ufix4
  input   AXI_Lite_WVALID;  // ufix1
  input   AXI_Lite_BREADY;  // ufix1
  input   [31:0] AXI_Lite_ARADDR;  // ufix32
  input   AXI_Lite_ARVALID;  // ufix1
  input   AXI_Lite_RREADY;  // ufix1
  input   [31:0] data_read;  // ufix32
  output  AXI_Lite_AWREADY;  // ufix1
  output  AXI_Lite_WREADY;  // ufix1
  output  [1:0] AXI_Lite_BRESP;  // ufix2
  output  AXI_Lite_BVALID;  // ufix1
  output  AXI_Lite_ARREADY;  // ufix1
  output  [31:0] AXI_Lite_RDATA;  // ufix32
  output  [1:0] AXI_Lite_RRESP;  // ufix2
  output  AXI_Lite_RVALID;  // ufix1
  output  [31:0] data_write;  // ufix32
  output  [13:0] addr_sel;  // ufix14
  output  wr_enb;  // ufix1
  output  rd_enb;  // ufix1
  output  reset_internal;  // ufix1


  wire reset;
  wire enb;
  wire const_1;  // ufix1
  reg [7:0] axi_lite_wstate;  // uint8
  reg [7:0] axi_lite_rstate;  // uint8
  reg [7:0] axi_lite_wstate_next;  // uint8
  reg [7:0] axi_lite_rstate_next;  // uint8
  reg  AXI_Lite_AWREADY_1;  // ufix1
  reg  AXI_Lite_WREADY_1;  // ufix1
  reg  AXI_Lite_BVALID_1;  // ufix1
  reg  AXI_Lite_ARREADY_1;  // ufix1
  reg  AXI_Lite_RVALID_1;  // ufix1
  reg  aw_transfer;  // ufix1
  reg  w_transfer;  // ufix1
  reg  ar_transfer;  // ufix1
  wire [1:0] const_0_2;  // ufix2
  reg [31:0] AXI_Lite_RDATA_1;  // ufix32
  reg [31:0] wdata;  // ufix32
  reg [31:0] waddr;  // ufix32
  wire [13:0] waddr_sel;  // ufix14
  wire [13:0] raddr_sel;  // ufix14
  reg  wr_enb_1;  // ufix1
  wire strobe_addr;  // ufix1
  wire strobe_sel;  // ufix1
  wire const_zero;  // ufix1
  wire strobe_in;  // ufix1
  wire strobe_sw;  // ufix1
  reg  soft_reset;  // ufix1
  reg  axi_lite_out0_0_1;
  reg  axi_lite_out1_0_1;
  reg  axi_lite_out3_0_1;
  reg  axi_lite_awvalid_1;
  reg  axi_lite_wvalid_1;
  reg  axi_lite_arvalid_1;


  assign const_1 = 1'b1;



  assign enb = const_1;

  assign reset =  ~ AXI_Lite_ARESETN;



  always @(posedge CLK_IN)
    begin : axi_lite_process
      if (reset == 1'b1) begin
        axi_lite_wstate <= 8'd0;
        axi_lite_rstate <= 8'd0;
      end
      else if (enb) begin
        axi_lite_wstate <= axi_lite_wstate_next;
        axi_lite_rstate <= axi_lite_rstate_next;
      end
    end

  always @(axi_lite_wstate, axi_lite_rstate, AXI_Lite_AWVALID, AXI_Lite_WVALID,
       AXI_Lite_BREADY, AXI_Lite_ARVALID, AXI_Lite_RREADY) begin
    axi_lite_wstate_next = axi_lite_wstate;
    axi_lite_rstate_next = axi_lite_rstate;
    if (AXI_Lite_AWVALID != 1'b0) begin
      axi_lite_awvalid_1 = 1'b1;
    end
    else begin
      axi_lite_awvalid_1 = 1'b0;
    end
    if (AXI_Lite_WVALID != 1'b0) begin
      axi_lite_wvalid_1 = 1'b1;
    end
    else begin
      axi_lite_wvalid_1 = 1'b0;
    end
    if (AXI_Lite_ARVALID != 1'b0) begin
      axi_lite_arvalid_1 = 1'b1;
    end
    else begin
      axi_lite_arvalid_1 = 1'b0;
    end

    case ( axi_lite_wstate)
      8'd0 :
        begin
          axi_lite_out0_0_1 = 1'b1;
          axi_lite_out1_0_1 = 1'b0;
          AXI_Lite_BVALID_1 = 1'b0;
          if (axi_lite_awvalid_1) begin
            axi_lite_wstate_next = 8'd1;
          end
          else begin
            axi_lite_wstate_next = 8'd0;
          end
        end
      8'd1 :
        begin
          axi_lite_out0_0_1 = 1'b0;
          axi_lite_out1_0_1 = 1'b1;
          AXI_Lite_BVALID_1 = 1'b0;
          if (axi_lite_wvalid_1) begin
            axi_lite_wstate_next = 8'd2;
          end
          else begin
            axi_lite_wstate_next = 8'd1;
          end
        end
      8'd2 :
        begin
          axi_lite_out0_0_1 = 1'b0;
          axi_lite_out1_0_1 = 1'b0;
          AXI_Lite_BVALID_1 = 1'b1;
          if (AXI_Lite_BREADY != 1'b0) begin
            axi_lite_wstate_next = 8'd0;
          end
          else begin
            axi_lite_wstate_next = 8'd2;
          end
        end
      default :
        begin
          axi_lite_out0_0_1 = 1'b0;
          axi_lite_out1_0_1 = 1'b0;
          AXI_Lite_BVALID_1 = 1'b0;
          axi_lite_wstate_next = 8'd0;
        end
    endcase


    case ( axi_lite_rstate)
      8'd0 :
        begin
          axi_lite_out3_0_1 = 1'b1;
          AXI_Lite_RVALID_1 = 1'b0;
          if (axi_lite_arvalid_1) begin
            axi_lite_rstate_next = 8'd1;
          end
          else begin
            axi_lite_rstate_next = 8'd0;
          end
        end
      8'd1 :
        begin
          axi_lite_out3_0_1 = 1'b0;
          AXI_Lite_RVALID_1 = 1'b1;
          if (AXI_Lite_RREADY != 1'b0) begin
            axi_lite_rstate_next = 8'd0;
          end
          else begin
            axi_lite_rstate_next = 8'd1;
          end
        end
      default :
        begin
          axi_lite_out3_0_1 = 1'b0;
          AXI_Lite_RVALID_1 = 1'b0;
          axi_lite_rstate_next = 8'd0;
        end
    endcase

    AXI_Lite_AWREADY_1 = axi_lite_out0_0_1;
    AXI_Lite_WREADY_1 = axi_lite_out1_0_1;
    AXI_Lite_ARREADY_1 = axi_lite_out3_0_1;
    aw_transfer = axi_lite_awvalid_1 && axi_lite_out0_0_1;
    w_transfer = axi_lite_wvalid_1 && axi_lite_out1_0_1;
    ar_transfer = axi_lite_arvalid_1 && axi_lite_out3_0_1;
  end



  assign const_0_2 = 2'b00;



  assign AXI_Lite_BRESP = const_0_2;

  always @(posedge CLK_IN)
    begin : reg_rdata_process
      if (reset == 1'b1) begin
        AXI_Lite_RDATA_1 <= 32'b00000000000000000000000000000000;
      end
      else if (enb && ar_transfer) begin
        AXI_Lite_RDATA_1 <= data_read;
      end
    end



  assign AXI_Lite_RRESP = const_0_2;

  always @(posedge CLK_IN)
    begin : reg_wdata_process
      if (reset == 1'b1) begin
        wdata <= 32'b00000000000000000000000000000000;
      end
      else if (enb && w_transfer) begin
        wdata <= AXI_Lite_WDATA;
      end
    end



  assign data_write = wdata;

  always @(posedge CLK_IN)
    begin : reg_waddr_process
      if (reset == 1'b1) begin
        waddr <= 32'b00000000000000000000000000000000;
      end
      else if (enb && aw_transfer) begin
        waddr <= AXI_Lite_AWADDR;
      end
    end



  assign waddr_sel = waddr[15:2];



  assign raddr_sel = AXI_Lite_ARADDR[15:2];



  assign addr_sel = (AXI_Lite_ARVALID == 1'b0 ? waddr_sel :
              raddr_sel);



  always @(posedge CLK_IN)
    begin : reg_wr_enb_process
      if (reset == 1'b1) begin
        wr_enb_1 <= 1'b0;
      end
      else if (enb) begin
        wr_enb_1 <= w_transfer;
      end
    end



  assign rd_enb = ar_transfer;

  assign strobe_addr = (waddr_sel == 14'b00000000000000 ? 1'b1 :
              1'b0);



  assign strobe_sel = strobe_addr & wr_enb_1;



  assign const_zero = 1'b0;



  assign strobe_in = wdata[0];



  assign strobe_sw = (strobe_sel == 1'b0 ? const_zero :
              strobe_in);



  always @(posedge CLK_IN)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        soft_reset <= 1'b0;
      end
      else if (enb) begin
        soft_reset <= strobe_sw;
      end
    end



  assign reset_internal = reset | soft_reset;



  assign AXI_Lite_AWREADY = AXI_Lite_AWREADY_1;

  assign AXI_Lite_WREADY = AXI_Lite_WREADY_1;

  assign AXI_Lite_BVALID = AXI_Lite_BVALID_1;

  assign AXI_Lite_ARREADY = AXI_Lite_ARREADY_1;

  assign AXI_Lite_RDATA = AXI_Lite_RDATA_1;

  assign AXI_Lite_RVALID = AXI_Lite_RVALID_1;

  assign wr_enb = wr_enb_1;

endmodule  // controllerperipheralhdladi_pcore_axi_lite_module

